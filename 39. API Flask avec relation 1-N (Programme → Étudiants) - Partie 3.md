# <h1 id="cours-flask-sqlalchemy-1n">Cours – API Flask avec relation 1\:N (Programme → Étudiants)</h1>

## Objectif pédagogique

Vous allez apprendre à :

* Créer deux modèles liés : `Programme` et `Etudiant`
* Gérer une relation **un-à-plusieurs (1\:N)** avec SQLAlchemy
* Créer des routes pour manipuler les deux entités
* Comprendre comment relier des entités via une **clé étrangère**
* Obtenir les étudiants associés à un programme



## <h2 id="1-contexte">1. Contexte de la relation</h2>

### Objectif :

* Un **programme** (ex. Informatique) peut avoir **plusieurs étudiants** inscrits
* Un **étudiant** est inscrit dans **un seul programme**

### Représentation (relation 1\:N)

```
Programme (1) ─────────── (N) Etudiants
```



## <h2 id="2-structure">2. Structure du projet</h2>

```
projet_api_relation_1n/
├── env/
├── app.py
├── models.py
└── etudiants.db
```



## <h2 id="3-models">3. Modèles `Programme` et `Etudiant`</h2>

**Fichier : `models.py`**

```python
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()

class Programme(db.Model):
    __tablename__ = "programmes"
    id = db.Column(db.Integer, primary_key=True)
    nom = db.Column(db.String(100), nullable=False)

    # Relation vers les étudiants
    etudiants = db.relationship("Etudiant", back_populates="programme", cascade="all, delete")

    def to_dict(self):
        return {
            "id": self.id,
            "nom": self.nom,
            "etudiants": [e.to_dict_basic() for e in self.etudiants]
        }

class Etudiant(db.Model):
    __tablename__ = "etudiants"
    id = db.Column(db.Integer, primary_key=True)
    nom = db.Column(db.String(100), nullable=False)
    prenom = db.Column(db.String(100), nullable=False)
    programme_id = db.Column(db.Integer, db.ForeignKey("programmes.id"))

    # Relation inverse vers Programme
    programme = db.relationship("Programme", back_populates="etudiants")

    def to_dict(self):
        return {
            "id": self.id,
            "nom": self.nom,
            "prenom": self.prenom,
            "programme": self.programme.nom if self.programme else None
        }

    def to_dict_basic(self):
        return {
            "id": self.id,
            "nom": self.nom,
            "prenom": self.prenom
        }
```



## <h2 id="4-app">4. Application Flask principale</h2>

**Fichier : `app.py`**

```python
from flask import Flask, request, jsonify
from models import db, Programme, Etudiant

app = Flask(__name__)
app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///etudiants.db"
app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False

db.init_app(app)

@app.before_first_request
def create_tables():
    db.create_all()
```



## <h2 id="5-routes-programmes">5. Routes pour `Programme`</h2>

### a. Ajouter un programme

```python
@app.route("/api/programmes", methods=["POST"])
def ajouter_programme():
    data = request.get_json()
    nom = data.get("nom")
    if not nom:
        return jsonify({"message": "Le nom du programme est requis"}), 400
    programme = Programme(nom=nom)
    db.session.add(programme)
    db.session.commit()
    return jsonify(programme.to_dict()), 201
```



### b. Obtenir tous les programmes + étudiants associés

```python
@app.route("/api/programmes", methods=["GET"])
def get_programmes():
    programmes = Programme.query.all()
    return jsonify([p.to_dict() for p in programmes])
```



### c. Supprimer un programme (avec ses étudiants)

```python
@app.route("/api/programmes/<int:id>", methods=["DELETE"])
def supprimer_programme(id):
    programme = Programme.query.get(id)
    if not programme:
        return jsonify({"message": "Programme introuvable"}), 404
    db.session.delete(programme)
    db.session.commit()
    return jsonify({"message": "Programme supprimé avec succès"})
```



## <h2 id="6-routes-etudiants">6. Routes pour `Etudiant`</h2>

### a. Ajouter un étudiant lié à un programme

```python
@app.route("/api/etudiants", methods=["POST"])
def ajouter_etudiant():
    data = request.get_json()
    nom = data.get("nom")
    prenom = data.get("prenom")
    programme_id = data.get("programme_id")

    if not (nom and prenom and programme_id):
        return jsonify({"message": "Champs requis : nom, prénom, programme_id"}), 400

    programme = Programme.query.get(programme_id)
    if not programme:
        return jsonify({"message": "Programme non trouvé"}), 404

    etudiant = Etudiant(nom=nom, prenom=prenom, programme=programme)
    db.session.add(etudiant)
    db.session.commit()
    return jsonify(etudiant.to_dict()), 201
```

---

### b. Obtenir tous les étudiants

```python
@app.route("/api/etudiants", methods=["GET"])
def get_etudiants():
    etudiants = Etudiant.query.all()
    return jsonify([e.to_dict() for e in etudiants])
```


## <h2 id="7-test">7. Test avec `curl` ou Postman</h2>

### a. Créer un programme

```bash
curl -X POST http://localhost:5000/api/programmes \
-H "Content-Type: application/json" \
-d "{\"nom\": \"Informatique\"}"
```

### b. Ajouter un étudiant dans ce programme

```bash
curl -X POST http://localhost:5000/api/etudiants \
-H "Content-Type: application/json" \
-d "{\"nom\": \"Leclerc\", \"prenom\": \"Sophie\", \"programme_id\": 1}"
```



## <h2 id="8-verification">8. Vérifier la structure</h2>

### Programme (Informatique)

```json
{
  "id": 1,
  "nom": "Informatique",
  "etudiants": [
    {
      "id": 1,
      "nom": "Leclerc",
      "prenom": "Sophie"
    }
  ]
}
```



## <h2 id="9-structure-finale">9. Structure finale du projet</h2>

```
projet_api_relation_1n/
│
├── env/
├── app.py
├── models.py
├── etudiants.db
└── requirements.txt (optionnel)
```



## <h2 id="10-resume">10. Résumé pédagogique</h2>

| Élément          | Description                                                |
| ---------------- | ---------------------------------------------------------- |
| `Programme`      | Classe représentant une filière ou domaine d’études        |
| `Etudiant`       | Classe représentant une personne liée à un programme       |
| `programme_id`   | Clé étrangère (ForeignKey) dans `Etudiant`                 |
| `relationship()` | Utilisé dans les deux classes pour la relation 1\:N        |
| `back_populates` | Permet la navigation dans les deux sens (bidirectionnelle) |

