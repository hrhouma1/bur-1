# <h1 id="tp-gestion-etudiants-pyqt6">TP ‚Äì Syst√®me de gestion d‚Äô√©tudiants avec interface graphique PyQt6</h1>

## <h2 id="objectif">Objectif p√©dagogique</h2>

D√©velopper une application graphique en Python √† l‚Äôaide de **PyQt6**, permettant la gestion d‚Äôun carnet d‚Äô√©tudiants. L‚Äôapplication doit comporter une interface conviviale, permettre l‚Äôajout, la visualisation et la recherche d‚Äô√©tudiants, et utiliser un syst√®me de donn√©es persistantes (dictionnaire, fichier ou base de donn√©es).



## <h2 id="ressource-video">Ressource obligatoire</h2>

Vous devez vous baser sur la vid√©o suivante comme point de d√©part pour comprendre la structure d‚Äôun projet PyQt6 :

üîó **Vid√©o de r√©f√©rence** :
- *[https://www.youtube.com/watch?v=2WuHs-5kMl0](https://www.youtube.com/watch?v=2WuHs-5kMl0)* 
- *Titre : 017 PyQt6 Programs | Students Information Management System ‚Äì Full Tutorial*

> Il s‚Äôagit d‚Äôun tutoriel complet que vous devez √©tudier pour comprendre l‚Äôarchitecture d‚Äôun projet PyQt6 professionnel. Vous √™tes libres de le reproduire en partie, de l‚Äôadapter ou de vous en inspirer pour votre propre application.


## <h2 id="livrables">Livrables attendus</h2>

1. Une application fonctionnelle (.py) conforme aux exigences du sujet.
2. Un **d√©p√¥t Git contenant au moins 8 commits distincts et significatifs** (voir section ci-dessous).
3. Un fichier `README.md` expliquant le fonctionnement de votre application.
4. Un court fichier `rapport.txt` (ou `.pdf`) contenant :

   * un sch√©ma de l‚Äôinterface,
   * la structure de vos fichiers,
   * la description des principaux composants et classes utilis√©s.



## <h2 id="structure-commits">Structure des commits Git attendue</h2>

Vous devez faire des commits structur√©s √† chaque √©tape cl√© du d√©veloppement. Voici les **commits obligatoires minimaux** :

| Num√©ro | √âtape de d√©veloppement                  | Exemple de message de commit                     |
| ------ | --------------------------------------- | ------------------------------------------------ |
| 1      | Cr√©ation du projet                      | `Initialisation du projet PyQt6`                 |
| 2      | Ajout des d√©pendances                   | `Ajout des biblioth√®ques n√©cessaires`            |
| 3      | Cr√©ation de la fen√™tre principale       | `Cr√©ation de l'interface principale`             |
| 4      | Ajout de composants (formulaire, liste) | `Ajout du formulaire d'ajout d'√©tudiant`         |
| 5      | Connexion aux donn√©es                   | `Connexion √† la base SQLite` (ou autre)          |
| 6      | Fonctionnalit√© termin√©e                 | `Ajout d'un √©tudiant et affichage dans la liste` |
| 7      | Gestion des erreurs                     | `Ajout des messages d'erreur et validations`     |
| 8      | Finalisation                            | `Finalisation, nettoyage et documentation`       |


<br/>

# Annexe 2 - workflow de l'application Pyside6_Students_Information_Management_System

Ce projet est une **application de gestion d‚Äôinformations d‚Äô√©tudiants** avec une interface graphique d√©velopp√©e en **PySide6** (binding Python pour Qt6). Elle permet √† l‚Äôutilisateur de :

* Ajouter un nouvel √©tudiant
* Modifier ou supprimer les informations d‚Äôun √©tudiant existant
* Rechercher un √©tudiant √† partir de certains crit√®res
* Visualiser tous les √©tudiants enregistr√©s dans une base de donn√©es
* S√©lectionner un √©tudiant pour pr√©-remplir le formulaire



## Fichier principal : `main.py`

Lorsque le fichier `main.py` est ex√©cut√©, les √©tapes suivantes sont d√©clench√©es :

```python
if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec())
```

1. `QApplication(sys.argv)` : instancie l'application Qt, n√©cessaire pour ex√©cuter toute interface graphique avec Qt.
2. `window = MainWindow()` : cr√©e la fen√™tre principale, d√©finie dans la classe `MainWindow`.
3. `window.show()` : rend visible la fen√™tre principale.
4. `app.exec()` : d√©marre la boucle principale de l'application, qui g√®re les √©v√©nements utilisateurs.



## Classe `MainWindow(QMainWindow)`

C'est la classe qui g√®re l'ensemble de l'interface utilisateur et les interactions. Sa m√©thode `__init__()` est le point d‚Äôentr√©e de la logique applicative.

### Structure de `__init__()` :

```python
def __init__(self):
    super().__init__()
    
    # Cr√©ation de l'interface utilisateur (issue du fichier .ui)
    self.ui = Ui_Form()
    self.ui.setupUi(self)

    # Instanciation de l'objet pour la gestion de la base de donn√©es
    self.db_manager = DatabaseManager()

    # Configuration initiale
    self.setup_ui()
    self.connect_signals()
    self.load_students()
```

1. `self.ui = Ui_Form()` : cr√©e une instance de l'interface utilisateur g√©n√©r√©e automatiquement √† partir de Qt Designer.
2. `self.ui.setupUi(self)` : applique cette interface √† la fen√™tre principale.
3. `self.db_manager = DatabaseManager()` : instancie le gestionnaire de base de donn√©es (non visible ici, probablement SQLite).
4. Appel √† trois m√©thodes internes pour finaliser l‚Äôinitialisation :

   * `setup_ui()` : configure certains composants suppl√©mentaires de l‚Äôinterface.
   * `connect_signals()` : relie les boutons et les champs √† des fonctions Python.
   * `load_students()` : charge les donn√©es initiales depuis la base et les affiche dans le tableau.



## M√©thodes appel√©es depuis `__init__()`

### 1. `setup_ui()`

* Charge les √©tats dans la liste d√©roulante (exemple : Qu√©bec, Alberta, etc.)
* Pr√©pare les param√®tres visuels ou initialise des valeurs par d√©faut

### 2. `connect_signals()`

* Relie les boutons de l‚Äôinterface graphique aux fonctions correspondantes :

  * `btnAdd.clicked.connect(self.add_student)`
  * `btnUpdate.clicked.connect(self.update_student)`
  * `btnDelete.clicked.connect(self.delete_student)`
  * `btnSearch.clicked.connect(self.search_students)`
  * `btnClear.clicked.connect(self.clear_fields)`
  * `btnSelect.clicked.connect(self.select_student)`
* Peut √©galement connecter la s√©lection dans le tableau √† `on_table_selection_changed`

### 3. `load_students()`

* Appelle la m√©thode `get_all_students()` du `DatabaseManager`
* Ensuite appelle `populate_table()` avec les donn√©es re√ßues
* Affiche les √©tudiants dans le tableau principal de l‚Äôinterface



## R√©sum√© des m√©thodes m√©tier (fonctions principales)

| M√©thode                        | Description                                                                     |
| ------------------------------ | ------------------------------------------------------------------------------- |
| `add_student()`                | Lit les donn√©es du formulaire, les valide, puis les ins√®re dans la base         |
| `update_student()`             | Met √† jour un enregistrement s√©lectionn√© dans la base                           |
| `delete_student()`             | Supprime l‚Äô√©tudiant s√©lectionn√© dans le tableau                                 |
| `search_students()`            | Ex√©cute une recherche en fonction des champs remplis                            |
| `select_student()`             | R√©cup√®re les donn√©es de la ligne s√©lectionn√©e et les affiche dans le formulaire |
| `clear_fields()`               | Vide tous les champs du formulaire                                              |
| `get_form_data()`              | Lit les donn√©es saisies dans le formulaire                                      |
| `validate_form_data(data)`     | V√©rifie que les champs requis sont correctement remplis                         |
| `populate_table(students)`     | Ins√®re les donn√©es dans le tableau de l‚Äôinterface                               |
| `on_table_selection_changed()` | R√©agit √† la s√©lection d‚Äôune ligne dans le tableau                               |



## Cycle typique : ajout d‚Äôun √©tudiant

1. L‚Äôutilisateur saisit les informations dans le formulaire.
2. Il clique sur le bouton **Add**.
3. Le bouton est reli√© √† `add_student()` via `connect_signals()`.
4. `add_student()` appelle :

   * `get_form_data()` pour r√©cup√©rer les champs
   * `validate_form_data()` pour les valider
   * `self.db_manager.insert_student(...)` pour les enregistrer
5. Une fois l‚Äôinsertion r√©ussie, `load_students()` est rappel√©e pour rafra√Æchir le tableau.



<br/>

# Annexe 3 - Qu‚Äôest-ce qu‚Äôun signal ?

Dans une interface graphique, un **signal** est un **√©v√©nement** d√©clench√© par l‚Äôutilisateur ou par le syst√®me.

Par exemple :

* Quand on **clique sur un bouton**, un signal est envoy√©.
* Quand on **s√©lectionne une ligne dans un tableau**, un signal est envoy√©.
* Quand on **change le texte dans un champ**, un signal est envoy√©.

> En r√©sum√© : **Un signal = une action qui se produit dans l'interface.**

Mais un signal **ne fait rien tout seul**. Il faut lui dire **quoi faire** quand il se d√©clenche. C‚Äôest l√† qu‚Äôon utilise une **fonction appel√©e "slot"** (ou juste une m√©thode en Python).



## Exemples dans ton projet

Prenons un bouton. Tu as dans ton interface un bouton **"Add"** (Ajouter).

Tu veux que **quand on clique dessus, √ßa appelle la fonction `add_student()`**.

Voici ce que tu √©cris dans `connect_signals()` :

```python
self.ui.btnAdd.clicked.connect(self.add_student)
```

D√©composition :

* `self.ui.btnAdd` : c‚Äôest ton bouton.
* `.clicked` : c‚Äôest le **signal** que le bouton envoie quand on clique dessus.
* `.connect(...)` : √ßa relie ce signal √† une **fonction √† appeler**.
* `self.add_student` : c‚Äôest la fonction que tu veux ex√©cuter.

---

## Autres exemples dans ton projet

```python
self.ui.btnUpdate.clicked.connect(self.update_student)
self.ui.btnDelete.clicked.connect(self.delete_student)
self.ui.btnSearch.clicked.connect(self.search_students)
self.ui.btnClear.clicked.connect(self.clear_fields)
```

√Ä chaque fois :

* Le bouton d√©clenche un signal quand on clique.
* Ce signal est **connect√©** √† une m√©thode qui va faire le travail.



## Pourquoi c‚Äôest important ?

C‚Äôest ce qui permet √† ton interface de **r√©agir aux actions de l‚Äôutilisateur**.

Sans cette connexion entre signal et fonction, **cliquer sur un bouton ne ferait rien**.


## Analogie simple

Imagine un **interrupteur de lumi√®re** :

* L'interrupteur = le bouton (dans l'interface)
* Appuyer dessus = le signal (ex: `clicked`)
* La lampe qui s‚Äôallume = la fonction qu‚Äôon appelle (`add_student()` par exemple)

Tu dois **relier le fil entre l‚Äôinterrupteur et la lampe**. C‚Äôest ce que fait `.connect()`.

---

## R√©capitulatif

| Terme        | D√©finition simplifi√©e                              |
| ------------ | -------------------------------------------------- |
| Signal       | Quelque chose qui **se passe** (clic, texte, etc.) |
| Slot         | Une fonction qu‚Äôon veut **ex√©cuter** en r√©ponse    |
| `.connect()` | Lien entre le signal et la fonction                |





# R√©f√©rences:

Voici les liens de r√©f√©rence :

* [https://www.youtube.com/watch?v=2WuHs-5kMl0](https://www.youtube.com/watch?v=2WuHs-5kMl0)
* [https://github.com/CodeQuestions/PyQt5-Video-Book](https://github.com/CodeQuestions/PyQt5-Video-Book)
* [https://fonts.google.com/icons](https://fonts.google.com/icons)



