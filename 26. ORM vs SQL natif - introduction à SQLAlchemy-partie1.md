# <h1 id="intro">Introduction à SQLAlchemy : ORM vs SQL Natif</h1>

Ce cours vous présente les concepts fondamentaux de la **programmation avec ORM** à travers l’exemple de **SQLAlchemy**, l’un des ORM les plus utilisés en Python. Il s’adresse à des débutants ayant déjà vu du SQL natif (ex. avec SQLite ou MySQL) et souhaitant migrer vers une approche plus modulaire, réutilisable et maintenable.



## <h1 id="orm-vs-sql-natif">1. ORM vs SQL natif</h1>

### <h2>1.1 Définition d’un ORM</h2>

Un **ORM (Object Relational Mapper)** est un outil qui **fait le pont entre le code Python (objets, classes)** et une **base de données relationnelle (tables, colonnes)**.

| SQL Natif                           | ORM (SQLAlchemy, Django ORM…)                   |
| ----------------------------------- | ----------------------------------------------- |
| Écriture manuelle de requêtes SQL   | Utilisation d’objets et de méthodes Python      |
| Résultats sous forme de tuples      | Résultats sous forme d’objets (class instances) |
| Code souvent difficile à réutiliser | Code modulaire et orienté objet                 |
| Nécessite des connaissances en SQL  | Apprentissage progressif sans SQL direct        |

### <h2>1.2 Avantages et inconvénients</h2>

| Critère               | SQL Natif                       | ORM SQLAlchemy                           |
| --------------------- | ------------------------------- | ---------------------------------------- |
| Performance brute     | ✅ Excellente                    | ⚠️ Peut être plus lent                   |
| Simplicité initiale   | ✅ Facile à débuter              | ⚠️ Syntaxe spécifique à apprendre        |
| Maintenabilité        | ❌ Code dur à maintenir          | ✅ Architecture claire (modèles, session) |
| Sécurité (SQLi)       | ❌ Requêtes concaténées à éviter | ✅ Protégé nativement                     |
| Migration/Portabilité | ❌ SQL dépendant du SGBD         | ✅ Multi-SGBD (SQLite, MySQL, PostgreSQL) |



## <h1 id="sqlalchemy-intro">2. Introduction à SQLAlchemy</h1>

### <h2>2.1 Installation</h2>

```bash
pip install sqlalchemy
```



### <h2>2.2 Philosophie de SQLAlchemy</h2>

SQLAlchemy propose deux styles d’utilisation :

* **Core** (bas niveau, proche du SQL natif)
* **ORM** (haut niveau, via des classes Python)

Dans ce cours, on se concentre sur la **partie ORM**, qui permet de :

* Créer des classes représentant des tables
* Manipuler des objets comme s’ils étaient des enregistrements
* Faire des requêtes sans écrire de SQL brut


## <h1 id="premier-modele">3. Créer son premier modèle ORM</h1>

### <h2>3.1 Configuration de la base SQLite</h2>

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import declarative_base, sessionmaker

# Crée un moteur connecté à une base SQLite locale
engine = create_engine("sqlite:///etudiants.db", echo=True)

# Base commune pour tous les modèles
Base = declarative_base()

# Création de la session
Session = sessionmaker(bind=engine)
session = Session()
```



### <h2>3.2 Définir une table comme une classe Python</h2>

```python
from sqlalchemy import Column, Integer, String

class Etudiant(Base):
    __tablename__ = "etudiants"
    
    id = Column(Integer, primary_key=True)
    nom = Column(String)
    prenom = Column(String)
    email = Column(String, unique=True)

    def __repr__(self):
        return f"<Etudiant(nom={self.nom}, email={self.email})>"
```


### <h2>3.3 Créer la table dans la base</h2>

```python
Base.metadata.create_all(engine)
```



## <h1 id="crud">4. Opérations CRUD avec SQLAlchemy ORM</h1>

### <h2>4.1 Créer (Create)</h2>

```python
etudiant = Etudiant(nom="Dupont", prenom="Jean", email="jean.dupont@example.com")
session.add(etudiant)
session.commit()
```



### <h2>4.2 Lire (Read)</h2>

```python
# Tous les étudiants
etudiants = session.query(Etudiant).all()

# Recherche par critère
jean = session.query(Etudiant).filter_by(nom="Dupont").first()
```



### <h2>4.3 Mettre à jour (Update)</h2>

```python
jean.email = "jean.dupont@college.qc.ca"
session.commit()
```



### <h2>4.4 Supprimer (Delete)</h2>

```python
session.delete(jean)
session.commit()
```



## <h1 id="requetes-avancees">5. Requêtes plus avancées</h1>

### <h2>5.1 Recherche avec `filter()` et `like()`</h2>

```python
# Tous les étudiants avec un email en @gmail
resultats = session.query(Etudiant).filter(Etudiant.email.like("%@gmail.com")).all()
```



### <h2>5.2 Tri et limites</h2>

```python
session.query(Etudiant).order_by(Etudiant.nom.asc()).limit(10).all()
```



### <h2>5.3 Compter les lignes</h2>

```python
nb_etudiants = session.query(Etudiant).count()
```



## <h1 id="comparaison">6. Comparaison SQL natif vs ORM</h1>

| Opération    | SQL natif                                     | SQLAlchemy ORM                             |
| ------------ | --------------------------------------------- | ------------------------------------------ |
| Insertion    | `INSERT INTO etudiants VALUES (...)`          | `session.add(obj)` + `session.commit()`    |
| Lecture      | `SELECT * FROM etudiants WHERE id = 1`        | `session.query(Etudiant).get(1)`           |
| Modification | `UPDATE etudiants SET nom = '...' WHERE id=1` | `obj.nom = "..."` + `session.commit()`     |
| Suppression  | `DELETE FROM etudiants WHERE id=1`            | `session.delete(obj)` + `session.commit()` |



## <h1 id="schema-complet">7. Exemple complet – Mini application</h1>

### Fichier `model.py`

```python
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.orm import declarative_base, sessionmaker

Base = declarative_base()
engine = create_engine("sqlite:///etudiants.db", echo=True)
Session = sessionmaker(bind=engine)
session = Session()

class Etudiant(Base):
    __tablename__ = "etudiants"
    id = Column(Integer, primary_key=True)
    nom = Column(String)
    prenom = Column(String)
    email = Column(String, unique=True)
```

### Fichier `main.py`

```python
from model import Base, Etudiant, session, engine

# Création de la table
Base.metadata.create_all(engine)

# Ajout
session.add(Etudiant(nom="Tremblay", prenom="Marie", email="marie.tremblay@gmail.com"))
session.commit()

# Lecture
for e in session.query(Etudiant).all():
    print(e)
```



## <h1 id="avantages-sqlalchemy">8. Pourquoi utiliser SQLAlchemy dans vos projets ?</h1>

* ✅ **Compatible avec tous les SGBD** : SQLite, PostgreSQL, MySQL, Oracle, etc.
* ✅ **Pas besoin d’écrire de SQL brut**
* ✅ **Sécurité accrue (contre injections SQL)**
* ✅ **Productivité accrue** dans les projets complexes
* ✅ **Architecture orientée objet claire**
* ✅ **Compatible avec des frameworks comme FastAPI ou Flask**



## <h1 id="exercices">9. Exercices pratiques</h1>

### <h2>Exercice 1 – Créer un modèle `Livre`</h2>

1. Attributs : `id`, `titre`, `auteur`, `annee`, `isbn`
2. Insérez 3 livres
3. Recherchez tous les livres publiés après 2000



### <h2>Exercice 2 – Convertir du SQL natif</h2>

Convertissez les requêtes suivantes en SQLAlchemy ORM :

1. `SELECT * FROM livres WHERE auteur='Orwell'`
2. `DELETE FROM livres WHERE id=3`



## <h1 id="ressources">10. Ressources utiles</h1>

* Documentation SQLAlchemy : [https://docs.sqlalchemy.org](https://docs.sqlalchemy.org)
* Tutoriel officiel : [https://docs.sqlalchemy.org/en/20/orm/tutorial.html](https://docs.sqlalchemy.org/en/20/orm/tutorial.html)
* ORM FastAPI + SQLAlchemy : [https://fastapi.tiangolo.com/tutorial/sql-databases/](https://fastapi.tiangolo.com/tutorial/sql-databases/)



## <h1 id="conclusion">11. Conclusion</h1>

**SQLAlchemy ORM** est un outil puissant permettant de structurer proprement le code Python pour interagir avec une base de données. Il favorise une architecture propre, réutilisable et sécurisée, en particulier dans des projets d’envergure ou collaboratifs. Comprendre les bases d’un ORM comme SQLAlchemy est indispensable pour tout développeur Python professionnel.



Souhaitez-vous également une **version "avec interface PyQt/PySide" connectée à SQLAlchemy**, ou un **TP guidé avec migration SQLite → SQLAlchemy ORM → MySQL/PostgreSQL** ?

